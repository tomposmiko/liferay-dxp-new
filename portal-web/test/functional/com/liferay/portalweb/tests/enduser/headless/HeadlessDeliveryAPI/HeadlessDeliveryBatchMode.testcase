@component-name = "portal-headless-frontend-infrastructure"
definition {

	property portal.release = "true";
	property portal.upstream = "true";
	property testray.main.component.name = "Headless Frontend Infrastructure";

	setUp {
		TestCase.setUpPortalInstanceNoSelenium();
	}

	tearDown {
		BlogPostingAPI.deleteAllBlogPostings();
	}

	@disable-webdriver = "true"
	@priority = "5"
	test CanCreateAndUpdateBlogPostingWithBatchPostCreateStrategyUpsert {
		property portal.acceptance = "true";

		task ("Given I use POST with parameter createStrategy set to UPSERT to create two blog posts") {
			BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "UPSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("When I repeat the same request changing all the parameters of the second blog post") {
			var importTaskId = BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "UPSERT",
				numberOfBlogPostingsToCreate = "2",
				testCase = "updateOneBlogPosting");
		}

		task ("Then I receive executeStatus: completed") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "COMPLETED");
		}

		task ("And Then the 3 blog postings are visible as created") {
			var actualNumberOfBlogPostings = BlogPostingAPI.getNumberOfBlogPostingsCreated();

			TestUtils.assertEquals(
				actual = "${actualNumberOfBlogPostings}",
				expected = "3");
		}
	}

	@disable-webdriver = "true"
	@priority = "5"
	test CanCreateBaseCommentWithBatchPostCreateStrategyInsert {
		property portal.acceptance = "true";

		task ("Given a blogPosting created") {
			var blogPostingId = BlogPostingAPI.getIdOfCreatedBlogPosting(
				articleBody = "myArticleBody",
				headline = "headline of my blog posting");
		}

		task ("When I use POST headless-delivery/v1.0/blog-postings/{blogPostingId}/comments/batch?createStrategy=INSERT to create two base comments") {
			var importTaskId = CommentAPI.getIdOfCreateNCommentsInBlogPostingBatchEngineImportTask(
				blogPostingId = "${blogPostingId}",
				createStrategy = "INSERT",
				numberOfCommentsToCreate = "2");
		}

		task ("Then I receive executeStatus: completed") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "COMPLETED");
		}

		task ("And Then the blog comments are created properly") {
			var blogCommentsText = CommentAPI.getBlogCommentsText(blogPostingId = "${blogPostingId}");

			TestUtils.assertEquals(
				actual = "${blogCommentsText}",
				expected = "<p>commentText1</p>,<p>commentText2</p>");
		}
	}

	@disable-webdriver = "true"
	@priority = "4"
	test CannotCreateTwoSameBlogPostingsWithBatchPostCreateStrategyInsert {
		property portal.acceptance = "true";

		task ("Given I use POST with parameter createStrategy set to INSERT to create two blog posts") {
			BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "INSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("When I repeat the same request again changing the headline") {
			var importTaskId = BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "INSERT",
				hadline = "new headline",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("Then I receive executeStatus: FAILED") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "FAILED");
		}
	}

	@disable-webdriver = "true"
	@priority = "4"
	test CannotCreateTwoSameBlogPostingsWithBatchPostCreateStrategyInsertWhenOneOfThemAlreadyExisting {
		property portal.acceptance = "true";

		task ("Given I use POST with parameter createStrategy set to INSERT to create two blog posts") {
			BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "INSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("When I repeat the same request again changing all the data of second blog post") {
			var importTaskId = BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "INSERT",
				numberOfBlogPostingsToCreate = "2",
				testCase = "updateOneBlogPosting");
		}

		task ("Then I receive executeStatus: FAILED") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "FAILED");
		}
	}

	@disable-webdriver = "true"
	@priority = "4"
	test CannotUpdateBlogPostingWithBatchPostCreateStrategyInsert {
		property portal.acceptance = "true";

		task ("Given I use POST with parameter createStrategy set to UPSERT to create two blog posts") {
			BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "UPSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("When I use POST with parameter createStrategy set to INSERT with the same data") {
			var importTaskId = BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "INSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("Then I receive executeStatus: failed") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "FAILED");
		}
	}

	@disable-webdriver = "true"
	@priority = "5"
	test CanUpdateBlogPostingWithBatchPostCreateStrategyUpsertWhenOneOfThemAlreadyExisting {
		property portal.acceptance = "true";

		task ("Given I use POST with parameter createStrategy set to UPSERT to create two blog posts") {
			BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "UPSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("When I repeat the same request again") {
			var importTaskId = BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "UPSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("Then I receive executeStatus: completed") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "COMPLETED");
		}

		task ("And Then the number of blog posting exiting is correct") {
			var actualNumberOfBlogPostings = BlogPostingAPI.getNumberOfBlogPostingsCreated();

			TestUtils.assertEquals(
				actual = "${actualNumberOfBlogPostings}",
				expected = "2");
		}
	}

	@disable-webdriver = "true"
	@priority = "5"
	test CanUpdateOneFieldOfBlogPostingWithBatchPutPartialUpdate {
		property portal.acceptance = "true";

		task ("Given a blogPosting created") {
			var blogPostingId = BlogPostingAPI.getIdOfCreatedBlogPosting(
				articleBody = "Blog Content",
				headline = "Blog Headline");
		}

		task ("When I use PUT 'http://localhost:8080/o/headless-delivery/v1.0/blog-postings/batch?updateStrategy=PARTIAL_UPDATE with created blogPostingId body parameter and one other body parameter to update ") {
			var importTaskId = BlogPostingAPI.getIdOfUpdateOneBlogPostingBodyParameter(
				blogPostingId = "${blogPostingId}",
				bodyParameterKey = "headline",
				bodyParameterValue = "Updated Headline",
				updateStrategy = "PARTIAL_UPDATE");
		}

		task ("Then I receive executeStatus: completed") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "COMPLETED");
		}

		task ("And Then the blog article body is updated") {
			var response = BlogPostingAPI._getBlogPostings();

			var blogPostingHeadline = BlogPostingAPI._getHeadlineOfExistingBlogPosting(response = "${response}");

			TestUtils.assertEquals(
				actual = "${blogPostingHeadline}",
				expected = "Updated Headline");
		}
	}

	@disable-webdriver = "true"
	@priority = "4"
	test CanUpdateWithBatchPostCreateStrategyUpsertBlogPostingCreatedWithBatchPostCreateStrategyInsert {
		property portal.acceptance = "true";

		task ("Given I use POST with parameter createStrategy set to INSERT to create two blog posts") {
			BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "INSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("When I use POST with parameter createStrategy set to UPSERT with the same data") {
			var importTaskId = BlogPostingAPI.getIdOfCreateNBlogPostingBatchEngineImportTask(
				createStrategy = "UPSERT",
				numberOfBlogPostingsToCreate = "2");
		}

		task ("Then I receive executeStatus: completed") {
			var executeStatus = ImportTask.getStatusOfImportTaskById(importTaskId = "${importTaskId}");

			TestUtils.assertEquals(
				actual = "${executeStatus}",
				expected = "COMPLETED");
		}

		task ("And Then the 2 blog postings are visible as created") {
			var actualNumberOfBlogPostings = BlogPostingAPI.getNumberOfBlogPostingsCreated();

			TestUtils.assertEquals(
				actual = "${actualNumberOfBlogPostings}",
				expected = "2");
		}
	}

}